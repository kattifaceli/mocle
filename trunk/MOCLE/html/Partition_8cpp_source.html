<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MOCLE: Partition.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>Partition.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Partition.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Created on: 09/02/2010</span>
<a name="l00005"></a>00005 <span class="comment"> *      Author: Valter</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;Partition.h&quot;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a><a class="code" href="classPartition.html#a9700c1c87842936c22fd9a3dc41740e1">00010</a> <a class="code" href="classPartition.html#a9700c1c87842936c22fd9a3dc41740e1">Partition::Partition</a>(<span class="keywordtype">string</span> sAPathPartition, <span class="keywordtype">string</span> sANamePartition) {
<a name="l00011"></a>00011         sPathPartition = sAPathPartition;
<a name="l00012"></a>00012         sNamePartition = sANamePartition;
<a name="l00013"></a>00013         <a class="code" href="classPartition.html#a025f8c250b2e7bb9d74ff18e6839105a">loadPartition</a>();
<a name="l00014"></a>00014 }
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 Partition::~Partition() {}
<a name="l00017"></a>00017 
<a name="l00018"></a><a class="code" href="classPartition.html#af9c0055c226e56ff0d02c935fc885b7b">00018</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#af9c0055c226e56ff0d02c935fc885b7b">Partition::calculateCentroid</a>(<a class="code" href="classDataSet.html" title="Responsible to manage the dataset file into the memory.">DataSet</a> *pAObjDataSet) {
<a name="l00019"></a>00019         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)vectorObjCluster.size(); i++)
<a name="l00020"></a>00020                 vectorObjCluster[i].<a class="code" href="classPartition.html#af9c0055c226e56ff0d02c935fc885b7b">calculateCentroid</a>(pAObjDataSet);
<a name="l00021"></a>00021 }
<a name="l00022"></a>00022 
<a name="l00023"></a><a class="code" href="classPartition.html#a2e226fe3b809239ceded7aa471339f2d">00023</a> vector&lt;string&gt; <a class="code" href="classPartition.html#a2e226fe3b809239ceded7aa471339f2d">Partition::getObjectsInCluster</a>(<span class="keywordtype">int</span> ClusterLabel){
<a name="l00024"></a>00024         <span class="keywordflow">return</span> vectorObjCluster[ClusterLabel].getVectorObjects();
<a name="l00025"></a>00025 }
<a name="l00026"></a>00026 
<a name="l00027"></a><a class="code" href="classPartition.html#ab2e66cdee06952b1d1417abedc1b86cc">00027</a> vector&lt;double&gt; <a class="code" href="classPartition.html#ab2e66cdee06952b1d1417abedc1b86cc">Partition::getCentroidInCluster</a>(<span class="keywordtype">int</span> ClusterLabel){
<a name="l00028"></a>00028         <span class="keywordflow">return</span> vectorObjCluster[ClusterLabel].getVectorCentroids();
<a name="l00029"></a>00029 }
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="classPartition.html#a30c36aee050b5a222f70feae3a48ab07">00031</a> vector&lt;Partition::Cluster&gt; <a class="code" href="classPartition.html#a30c36aee050b5a222f70feae3a48ab07">Partition::getVectorObjCluster</a>(){
<a name="l00032"></a>00032         <span class="keywordflow">return</span> vectorObjCluster;
<a name="l00033"></a>00033 }
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classPartition.html#a5c0dc502d21ecd15279ace3e9cf05cb2">00035</a> <span class="keywordtype">int</span> <a class="code" href="classPartition.html#a5c0dc502d21ecd15279ace3e9cf05cb2">Partition::getLabelClusterOf</a>(<span class="keywordtype">string</span> sAObject){
<a name="l00036"></a>00036         vector&lt;string&gt;::iterator itVectorObjects;
<a name="l00037"></a>00037         vector&lt;string&gt; vectorObjectsOnCluster;
<a name="l00038"></a>00038         itCluster it;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040         <span class="keywordflow">for</span>(it = begin(); it != end(); ++it){
<a name="l00041"></a>00041                 vectorObjectsOnCluster = it-&gt;getVectorObjects();
<a name="l00042"></a>00042 
<a name="l00043"></a>00043                 <span class="keywordflow">for</span>(itVectorObjects = vectorObjectsOnCluster.begin(); itVectorObjects != vectorObjectsOnCluster.end(); itVectorObjects++){
<a name="l00044"></a>00044 
<a name="l00045"></a>00045                         <span class="keywordflow">if</span>( (*itVectorObjects) == sAObject){
<a name="l00046"></a>00046                                 <span class="keywordflow">return</span> it-&gt;getLabel();
<a name="l00047"></a>00047                         }
<a name="l00048"></a>00048                 }
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050         <span class="keywordflow">return</span> -1; <span class="comment">//VERIFICAR SE A CONSTANTE DE ERRO SERA -1</span>
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="classPartition.html#a025f8c250b2e7bb9d74ff18e6839105a">00053</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#a025f8c250b2e7bb9d74ff18e6839105a">Partition::loadPartition</a>() {
<a name="l00054"></a>00054         Partition::Cluster *pObCluster;
<a name="l00055"></a>00055         <span class="keywordtype">string</span> sTemp;
<a name="l00056"></a>00056         <span class="keywordtype">string</span> sObject;
<a name="l00057"></a>00057         <span class="keywordtype">string</span> sPath = sPathPartition + sNamePartition;
<a name="l00058"></a>00058         <span class="keywordtype">int</span> iCluster;
<a name="l00059"></a>00059         <span class="keywordtype">int</span> i;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         ifstream in(sPath.c_str());
<a name="l00062"></a>00062 
<a name="l00063"></a>00063         <span class="comment">// define what gonna be the tokenizer character</span>
<a name="l00064"></a>00064         char_separator&lt;char&gt; sep(<span class="stringliteral">&quot;\t&quot;</span>);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066         <span class="keywordflow">while</span> (getline(in, sTemp)) {
<a name="l00067"></a>00067 
<a name="l00068"></a>00068                 <span class="comment">// tokenize the string sTemp that&apos;s the line read in the file informed in &apos;pathAPartition&apos;</span>
<a name="l00069"></a>00069                 tokenizer&lt;char_separator&lt;char&gt; &gt; tokens(sTemp, sep);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071                 <span class="keywordflow">for</span> (tokenizer&lt;char_separator&lt;char&gt; &gt;::iterator itTokens = tokens.begin(); itTokens != tokens.end(); ++itTokens) {
<a name="l00072"></a>00072 
<a name="l00073"></a>00073                         <span class="comment">// putting the ID of the element in the memory</span>
<a name="l00074"></a>00074                         <span class="comment">// mapVector[sIndexLine].push_back(dNumber);</span>
<a name="l00075"></a>00075                         sObject = *itTokens;
<a name="l00076"></a>00076                         ++itTokens;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078                         (istringstream(*itTokens) &gt;&gt; iCluster);
<a name="l00079"></a>00079                         mapObjects[sObject] = iCluster;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081                         i = 0;
<a name="l00082"></a>00082                         <span class="keywordflow">while</span> (i &lt; (<span class="keywordtype">int</span>)vectorObjCluster.size() &amp;&amp; (int)vectorObjCluster[i].getLabel()!= iCluster) {
<a name="l00083"></a>00083                                 i++;
<a name="l00084"></a>00084                         }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086                         <span class="keywordflow">if</span> (i == (<span class="keywordtype">int</span>)vectorObjCluster.size()) {
<a name="l00087"></a>00087                                 pObCluster = <span class="keyword">new</span> Cluster(iCluster, sObject);
<a name="l00088"></a>00088                                 vectorObjCluster.push_back(*pObCluster);
<a name="l00089"></a>00089                                 <span class="keyword">delete</span> pObCluster;
<a name="l00090"></a>00090                         } <span class="keywordflow">else</span>
<a name="l00091"></a>00091                                 vectorObjCluster[i].addObject(sObject);
<a name="l00092"></a>00092                 }
<a name="l00093"></a>00093         }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         iNumObjects = mapObjects.size();
<a name="l00096"></a>00096         iNumClusters =  vectorObjCluster.size();
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keywordtype">void</span> Partition::showCentroids(){
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         vector&lt;double&gt; vectorCentroid;
<a name="l00103"></a>00103         vector&lt;double&gt;::iterator itVectorCentroid;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iNumClusters; i++){
<a name="l00106"></a>00106 
<a name="l00107"></a>00107                  vectorCentroid = vectorObjCluster[i].getVectorCentroids();
<a name="l00108"></a>00108 
<a name="l00109"></a>00109                 <span class="keywordflow">for</span> (itVectorCentroid = vectorCentroid.begin(); itVectorCentroid != vectorCentroid.end(); ++itVectorCentroid){
<a name="l00110"></a>00110                         cout &lt;&lt; <span class="stringliteral">&quot;Cluster (&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;) | Centroid &gt;&gt; &quot;</span> &lt;&lt; *itVectorCentroid &lt;&lt; endl;
<a name="l00111"></a>00111                 }
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classPartition.html#a4204d0b43248fb2635607b8f87caff69">00116</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#a4204d0b43248fb2635607b8f87caff69">Partition::writePartition</a>() {
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         <span class="keywordtype">string</span> sFolder;
<a name="l00119"></a>00119         <span class="keywordtype">string</span> sNamePartition;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         cout &lt;&lt; <span class="stringliteral">&quot;Inform the name of the folder that you want save your partition&quot;</span> &lt;&lt; endl;
<a name="l00122"></a>00122         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00123"></a>00123         cin &gt;&gt; sFolder;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         <span class="comment">// # ficando o caminho para a nova pasta do tipo da partition</span>
<a name="l00126"></a>00126         cout &lt;&lt; <span class="stringliteral">&quot;New folder in : &quot;</span> &lt;&lt; sPathPartition + sFolder &lt;&lt; endl;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="comment">//fs::path pathPartition(sFolder);</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         <span class="comment">// # criando o diretório especificado pelo usuário</span>
<a name="l00131"></a>00131         fs::create_directories(sPathPartition+sFolder);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         cout &lt;&lt; <span class="stringliteral">&quot;Inform the name of the file that gonna be your partition&quot;</span> &lt;&lt; endl;
<a name="l00134"></a>00134         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00135"></a>00135         cin &gt;&gt; sNamePartition;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordtype">string</span> sPath = sPathPartition + sFolder + <span class="stringliteral">&quot;/&quot;</span> + sNamePartition + <span class="stringliteral">&quot;.clu&quot;</span>;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         cout &lt;&lt; <span class="stringliteral">&quot;sPath no partition &gt;&gt; &quot;</span> &lt;&lt; sPath;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         ofstream out(sPath.c_str());
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         map &lt;string, int&gt;::iterator itMapObjects;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="keywordflow">for</span>(itMapObjects = mapObjects.begin(); itMapObjects != mapObjects.end(); ++itMapObjects){
<a name="l00146"></a>00146                 out &lt;&lt; itMapObjects-&gt;first &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; itMapObjects-&gt;second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00147"></a>00147         }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         out.close();
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="classPartition.html#ac2382e6bd161f3dc1f3cb6cc2d4a42f2">00153</a> Partition::Cluster &amp; <a class="code" href="classPartition.html#ac2382e6bd161f3dc1f3cb6cc2d4a42f2">Partition::getCluster</a>(<span class="keywordtype">int</span> iPos) {
<a name="l00154"></a>00154         <span class="keywordflow">return</span> vectorObjCluster[iPos];
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a><a class="code" href="classPartition.html#ae78d06ba7708ffc35f93dfe166315c74">00157</a> <span class="keywordtype">int</span> <a class="code" href="classPartition.html#ae78d06ba7708ffc35f93dfe166315c74">Partition::getNumClusters</a>() {
<a name="l00158"></a>00158         <span class="keywordflow">return</span> iNumClusters;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a><a class="code" href="classPartition.html#ae59c41688846ed426c0fba2338543440">00161</a> <span class="keywordtype">int</span> <a class="code" href="classPartition.html#ae59c41688846ed426c0fba2338543440">Partition::getNumObjects</a>() {
<a name="l00162"></a>00162         <span class="keywordflow">return</span> iNumObjects;
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a><a class="code" href="classPartition.html#a4b2602b02fe2577c33b9f344a242cd32">00165</a> map&lt;string, int&gt; <a class="code" href="classPartition.html#a4b2602b02fe2577c33b9f344a242cd32">Partition::getMObjects</a>(){
<a name="l00166"></a>00166         <span class="keywordflow">return</span> mapObjects;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="classPartition.html#a9d6584bb879af33206176d912d8394d0">00169</a> vector&lt;Partition::Cluster&gt; <a class="code" href="classPartition.html#a9d6584bb879af33206176d912d8394d0">Partition::getVObjects</a>(){
<a name="l00170"></a>00170         <span class="keywordflow">return</span> vectorObjCluster;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">// in this method in generated a random partition, don&apos;t follow any standard</span>
<a name="l00174"></a><a class="code" href="classPartition.html#a2c1bdfc1d754486482e9b0225c4eb184">00174</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#a2c1bdfc1d754486482e9b0225c4eb184">Partition::generateRandomPartition</a>(<a class="code" href="classDataSet.html" title="Responsible to manage the dataset file into the memory.">DataSet</a> *pAObjDataSet) {
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         time_t rawtime;
<a name="l00177"></a>00177         <span class="keyword">struct </span>tm * timeinfo;
<a name="l00178"></a>00178         time (&amp;rawtime);
<a name="l00179"></a>00179         timeinfo = localtime(&amp;rawtime);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         <span class="keywordtype">string</span> sMonth = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_mon+1);
<a name="l00182"></a>00182         <span class="keywordtype">string</span> sDay   = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_mday);
<a name="l00183"></a>00183         <span class="keywordtype">string</span> sYear  = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(1900 + timeinfo-&gt;tm_year);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185         <span class="keywordtype">string</span> sHour   = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_hour);
<a name="l00186"></a>00186         <span class="keywordtype">string</span> sMinute = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_min);
<a name="l00187"></a>00187         <span class="keywordtype">string</span> sSecond = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_sec);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <span class="keywordtype">string</span> sFolder = sDay + <span class="stringliteral">&quot;|&quot;</span> + sMonth + <span class="stringliteral">&quot;|&quot;</span> + sYear + <span class="stringliteral">&quot; &quot;</span> + sHour + <span class="stringliteral">&quot;:&quot;</span> + sMinute + <span class="stringliteral">&quot;:&quot;</span> + sSecond;
<a name="l00190"></a>00190         <span class="keywordtype">string</span> sName;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordtype">int</span> iObjects = pAObjDataSet-&gt;<a class="code" href="classDataSet.html#ad871938d36c8988a8e921788cd0019f7">getNumberOfObjects</a>();
<a name="l00193"></a>00193         <span class="keywordtype">int</span> iNumClusters = -1;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         fs::create_directories(sPathPartition + sFolder);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         cout &lt;&lt; <span class="stringliteral">&quot;Inform the NAME of the new partition&quot;</span> &lt;&lt; endl;
<a name="l00198"></a>00198         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00199"></a>00199         cin &gt;&gt; sName;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <span class="comment">/*</span>
<a name="l00202"></a>00202 <span class="comment">        while (iObjects &lt;= 0 ){</span>
<a name="l00203"></a>00203 <span class="comment">                cout &lt;&lt; &quot;Inform the number of OBJECTS that you want in the new partition&quot; &lt;&lt; endl;</span>
<a name="l00204"></a>00204 <span class="comment">                cout &lt;&lt; &quot;&gt;&gt; &quot;;</span>
<a name="l00205"></a>00205 <span class="comment">                cin &gt;&gt; iObjects;</span>
<a name="l00206"></a>00206 <span class="comment">        }</span>
<a name="l00207"></a>00207 <span class="comment">        */</span>
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keywordflow">while</span> (iNumClusters &lt;= 0){
<a name="l00210"></a>00210                 cout &lt;&lt; <span class="stringliteral">&quot;Inform the number of CLUSTERS that you want in the new partition&quot;</span> &lt;&lt; endl;
<a name="l00211"></a>00211                 cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00212"></a>00212                 cin &gt;&gt; iNumClusters;
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="keywordtype">string</span> sNewPartition = sPathPartition + sFolder + <span class="stringliteral">&quot;/&quot;</span> + sName + <span class="stringliteral">&quot;.clu&quot;</span>;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         ofstream out( sNewPartition.c_str());
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iObjects; i++)       {
<a name="l00220"></a>00220                 out &lt;&lt; <span class="stringliteral">&quot;Element&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; rand()%iNumClusters + 1 &lt;&lt; endl;
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         out.close();
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="classPartition.html#a6e63e73de79cb57ef37261c15aedce47">00227</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#a6e63e73de79cb57ef37261c15aedce47">Partition::generatePartitionGroupCluster</a>(<a class="code" href="classDataSet.html" title="Responsible to manage the dataset file into the memory.">DataSet</a> *pAObjDataSet) {
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         time_t rawtime;
<a name="l00230"></a>00230         <span class="keyword">struct </span>tm * timeinfo;
<a name="l00231"></a>00231         time (&amp;rawtime);
<a name="l00232"></a>00232         timeinfo = localtime(&amp;rawtime);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         <span class="keywordtype">string</span> sMonth = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_mon+1);
<a name="l00235"></a>00235         <span class="keywordtype">string</span> sDay =   boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_mday);
<a name="l00236"></a>00236         <span class="keywordtype">string</span> sYear =  boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(1900 + timeinfo-&gt;tm_year);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordtype">string</span> sHour =   boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_hour);
<a name="l00239"></a>00239         <span class="keywordtype">string</span> sMinute = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_min);
<a name="l00240"></a>00240         <span class="keywordtype">string</span> sSecond = boost::lexical_cast&lt;<span class="keywordtype">string</span>&gt;(timeinfo-&gt;tm_sec);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="keywordtype">string</span> sFolder = sDay + <span class="stringliteral">&quot;|&quot;</span> + sMonth + <span class="stringliteral">&quot;|&quot;</span> + sYear + <span class="stringliteral">&quot; &quot;</span> + sHour + <span class="stringliteral">&quot;:&quot;</span> + sMinute + <span class="stringliteral">&quot;:&quot;</span> + sSecond;
<a name="l00243"></a>00243         <span class="keywordtype">string</span> sName;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         <span class="keywordtype">int</span> iObjects;
<a name="l00246"></a>00246         <span class="keywordtype">int</span> iNumClusters;
<a name="l00247"></a>00247         <span class="keywordtype">int</span> iCont = 0;
<a name="l00248"></a>00248         <span class="keywordtype">int</span> iCluster = 1;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         fs::create_directories(sPathPartition + sFolder);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         cout &lt;&lt; <span class="stringliteral">&quot;Provide the NAME of the new partition&quot;</span> &lt;&lt; endl;
<a name="l00253"></a>00253         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00254"></a>00254         cin &gt;&gt; sName;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         cout &lt;&lt; <span class="stringliteral">&quot;Provide the number of OBJECTS that you want in the new partition&quot;</span> &lt;&lt; endl;
<a name="l00257"></a>00257         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00258"></a>00258         cin &gt;&gt; iObjects;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         cout &lt;&lt; <span class="stringliteral">&quot;Provide the number of CLUSTERS that you want in the new partition&quot;</span> &lt;&lt; endl;
<a name="l00261"></a>00261         cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; &quot;</span>;
<a name="l00262"></a>00262         cin &gt;&gt; iNumClusters;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="keywordtype">string</span> sNewPartition = sPathPartition + sFolder + <span class="stringliteral">&quot;/&quot;</span> + sName + <span class="stringliteral">&quot;.clu&quot;</span>;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267         ofstream out( sNewPartition.c_str());
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt;= iObjects; i++){
<a name="l00270"></a>00270                 <span class="keywordflow">if</span> (iCont == (iObjects / iNumClusters)){
<a name="l00271"></a>00271                         iCluster++;
<a name="l00272"></a>00272                         iCont = 0;
<a name="l00273"></a>00273                 }
<a name="l00274"></a>00274                 iCont++;
<a name="l00275"></a>00275                 out &lt;&lt; i &lt;&lt; <span class="charliteral">&apos;\t&apos;</span> &lt;&lt; iCluster &lt;&lt; endl;
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         out.close();
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="comment">// # ambos os métodos printClusterLabels e printClusters fazem a mesma coisa, porém nota-se a simplificação de implementação de um método para o outro</span>
<a name="l00283"></a><a class="code" href="classPartition.html#a377ce02d44555898657ef992a1d4029a">00283</a> <span class="keywordtype">void</span> <a class="code" href="classPartition.html#a377ce02d44555898657ef992a1d4029a">Partition::printClusterLabels</a>(){
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <span class="keywordflow">for</span> (vector&lt;Partition::Cluster&gt;::iterator itVectorObjCluster = vectorObjCluster.begin(); itVectorObjCluster != vectorObjCluster.end(); ++ itVectorObjCluster){
<a name="l00286"></a>00286                 cout &lt;&lt; itVectorObjCluster-&gt;getLabel() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="comment">// # ambos os métodos printClusterLabels e printClusters fazem a mesma coisa, porém nota-se a simplificação de implementação de um método para o outro</span>
<a name="l00291"></a>00291 <span class="keywordtype">void</span> Partition::printClusters(){
<a name="l00292"></a>00292         itCluster it;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">for</span> (it = begin(); it != end(); ++ it){
<a name="l00295"></a>00295                 cout &lt;&lt; it-&gt;getLabel() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="comment">/******************</span>
<a name="l00301"></a>00301 <span class="comment">        Cluster</span>
<a name="l00302"></a>00302 <span class="comment">******************/</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 Partition::Cluster::Cluster(){}
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 Partition::Cluster::Cluster(<span class="keywordtype">int</span> iACluster, <span class="keywordtype">string</span> sAID) {
<a name="l00307"></a>00307         iLabel = iACluster;
<a name="l00308"></a>00308         vectorObjects.push_back(sAID);
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 vector&lt;string&gt; Partition::Cluster::getVectorObjects(){
<a name="l00312"></a>00312         <span class="keywordflow">return</span> vectorObjects;
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="keywordtype">void</span> Partition::Cluster::addObject(<span class="keywordtype">string</span> sAID) {
<a name="l00316"></a>00316         vectorObjects.push_back(sAID);
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="keywordtype">void</span> <a class="code" href="classPartition.html#af9c0055c226e56ff0d02c935fc885b7b">Partition::Cluster::calculateCentroid</a>(<a class="code" href="classDataSet.html" title="Responsible to manage the dataset file into the memory.">DataSet</a> *pAObjDataSet) {
<a name="l00320"></a>00320         <span class="keywordtype">double</span> dSum = 0;
<a name="l00321"></a>00321         <span class="keywordtype">int</span> iNumFeatures = pAObjDataSet-&gt;<a class="code" href="classDataSet.html#af747c49a69d26123a80a2da14eb40e13">getNumberOfFeature</a>();
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         vector&lt;double&gt; vectorAtributes;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <span class="comment">// a mapVector that will receive the mapVector from DataSet</span>
<a name="l00326"></a>00326         map&lt;string, vector&lt;double&gt; &gt; mapVector;
<a name="l00327"></a>00327         mapVector = pAObjDataSet-&gt;<a class="code" href="classDataSet.html#ab143b593863e69f9fb13383b2917f6f5">getMapVector</a>();
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="comment">// analyzing all that are a feature and adding their respective values and dividing by the number of elements that are in the same cluster, and storing this value vector of centroids, which have the values of the centroids</span>
<a name="l00330"></a>00330         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iNumFeatures; i++) {
<a name="l00331"></a>00331                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (int)vectorObjects.size(); j++) {
<a name="l00332"></a>00332                         vectorAtributes = mapVector.find(vectorObjects.at(j))-&gt;second;
<a name="l00333"></a>00333                         dSum += vectorAtributes.at(i);
<a name="l00334"></a>00334                 }
<a name="l00335"></a>00335                 vectorCentroid.push_back(dSum / vectorObjects.size());
<a name="l00336"></a>00336 
<a name="l00337"></a>00337                 <span class="comment">// zeroing to sum the next feature</span>
<a name="l00338"></a>00338                 dSum = 0;
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340 }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keywordtype">int</span> Partition::Cluster::getLabel() {
<a name="l00343"></a>00343         <span class="keywordflow">return</span> iLabel;
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keywordtype">int</span> Partition::Cluster::getNumberOfObjects() {
<a name="l00347"></a>00347         <span class="keywordflow">return</span> vectorObjects.size();
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 vector&lt;double&gt; Partition::Cluster::getVectorCentroids(){
<a name="l00351"></a>00351         <span class="keywordflow">return</span> vectorCentroid;
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 vector&lt;string&gt;::iterator Partition::Cluster::objectsItBegin() {
<a name="l00355"></a>00355         <span class="keywordflow">return</span> vectorObjects.begin();
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 vector&lt;string&gt;::iterator Partition::Cluster::objectsItEnd() {
<a name="l00359"></a>00359         <span class="keywordflow">return</span> vectorObjects.end();
<a name="l00360"></a>00360 }
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Jul 2010 for MOCLE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
